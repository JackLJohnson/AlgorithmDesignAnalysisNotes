\ifx\PREAMBLE\undefined
\input{preamble}
\begin{document}
\fi
\chapter{Greedy Algorithms}
In the field of algorithm design, there is no silver bullet suitable for all kinds of problems. We have covered divide-and-conquer paradigm and randomized algorithms. We will now introduce greedy algorithms, and in the next chapter we will dive into dynamic programming.

In a greedy algorithm, ``myopic'' decisions are made iteratively, in the hope that finally we will end up with a correct solution to the problem. Dijkstra's algorithm is actually a greedy algorithm. In contrast with divide-and-conquer algorithms, greedy algorithms have the following features:
\begin{itemize}
\item It is easy to propose multiple greedy algorithms for many problems.
\item It is relatively easy to analyze running times of greedy algorithms.
\item It is hard to establish the correctness of greedy algorithms. Proofs are usually ad-hoc. General approaches include induction (e.g. for Dijkstra) and ``exchange argument'', which will be covered later.
\item Most greedy algorithms are unfortunately incorrect.
\end{itemize}

A problem that can theoretically be solved by a greedy algorithm is the caching problem. Modern computers contain caches, sometimes a few layers. On a cache miss that happened at a page request, we have to evict something from the cache in order to make room for the newly requested page that is not in the cache. The choice of the item to evict influences greatly the number of cache misses. Some misses are inevitable, while others happen can be avoided by wise eviction choices. 

It can be proved via exchange argument that the ``furthest-in-future'' algorithm in the optimal solution to this problem. The algorithm always evicts the item that will take the longest time to be requested again. Although its correctness can be verified, this algorithm obviously cannot be implemented. Nonetheless it is useful as a guideline for practical algorithms like LRU(least-recently-used) algorithm, and it also serves as an idealized benchmark for caching algorithms.
\section{Scheduling}
\begin{description}
\item[Input]A set of $n$ jobs (e.g. processes) that have to use a shared resource (e.g. a processor) exclusively. Each job $j$ has a length $l_j$ and a weight $w_j$. 
\item[Output]An order to execute the jobs that minimizes the weighted sum of completion times $\sum\limits_{j=1}^{n}w_jC_j.$
\end{description}
Two simple cases of the problem are when the jobs have the same lengths / weights. If they have the same length, jobs with larger weights should be scheduled earlier, whereas if they are of the same weight, jobs with shorter lengths should go first. The scenarios might be extended to handle more general cases if we are able to resolve conflicts: what if $w_i>w_j$ and $l_i>l_j$? This can be achieved by assigning scores to jobs, and scheduling jobs with higher scores in front. The score has to increase with weight and decrease with length. Two intuitive choices are 
\begin{itemize}
\item $w_j-l_j$
\item $w_j/l_j$
\end{itemize}
A simple 2-job case with $l_1=5,\allowbreak w_1=3$ and $l_2=2,\allowbreak w_2=1$ rules the first option out. We will try to prove the correctness of the second option, whose correctness is absolutely not trivial.
\begin{proof}
First we assume that all jobs have distinct scores, i.e. $w_i/l_i\neq w_j/l_j$ for $i\neq j$. This case can be addressed via contradiction.

The $n$ jobs can be renamed so that $\frac{w_1}{l_1}>\frac{w_2}{l_2}>\dots>\frac{w_n}{l_n}$. According to the rule above, the optimal order should be $1,2,\dots,n$. Suppose that there exists an order superior to this one. In this order, there must exist at least one pair of consecutive jobs $i,j$ such that $i>j$ but $i$ is behind $j$. If we exchange $i,j$, the completion time of $i$ will decrease by $l_j$, whilst that of $j$ will increase by $l_i$. In total, the weighted sum of completion times decreases by
$$w_il_j-w_jl_i.$$
Since $i>j$, we must have $\frac{w_i}{l_i}>\frac{w_j}{l_j}$, thus $w_il_j>w_jl_i$. In conclusion, we have obtained a better order than the one supposed to be the optimal, which negates the initial assumption.

With similar argument, the correctness of the algorithm can be verified for the general case with possible ties in score. In an arbitrary order of the jobs, a consecutive pair $(i,j)$ with $i>j$ and $i$ behind $j$ can be called an inversion\footnote{The definition of inversion here is different from that in Algorithm \ref{inversioncounting}.} The number of inversions is at most $\frac{n(n-1)}{2}$, and the only order without any inversion is $1,2,\dots,n$. Since we have $w_il_j\geq w_jl_i$ for $i>j$, exchanging an inversion is guaranteed not to increase the weighted sum of completion times. Each exchange decreases the number of inversions strictly by one. Thus after at most $\frac{n(n-1)}{2}$ exchanges, we must arrive at the order $1,2,\dots,n$ with no increase of the weighted sum. Therefore $1,2,\dots,n$ is at least as good as any other order in terms of weighted sum of completion times, making it a guaranteed optimal solution to the scheduling problem.
\end{proof}
\section{Minimum Spanning Tree}
MST is a problem to which there exist a bunch of correct and fast greedy solutions. We will discuss two of them: Prim's algorithm and Kruskal's algorithm.
\begin{description}
\item[Input]An undirected graph $G(V,E)$ with a possibly negative cost $c_e$ for each $e\in E$. 
\item[Output]A minimum cost tree $T\subseteq E$ that spans all vertices, i.e. connected subgraph $(V,T)$ that contains no cycles with minimum sum of edge costs.
\end{description}
In order to facilitate the discussion, we assume that graph $G$ is connected, and that edge costs are distinct, although Prim and Kruskal remain correct for ties in edge costs.
\subsection{Prim's Algorithm}
Prim's MST algorithm is shown in Algorithm \ref{primmst}. 
\begin{algorithm}[ht]
\caption{Prim's MST Algorithm}\label{primmst}
\begin{algorithmic}[1]
\Input{Undirected graph $G(V,E)$ with distinct cost $c_e$ for all $e\in E$.}
\Output{MST of $G$}
\State{Initialize $X=\{s\}$, $s\in V$ chosen arbitrarily}
\State{Initialize $T=\emptyset$}
\While{$X\neq V$}
\State{Let $e=(u,v)$ be the cheapest edge of $G$ with $u\in X, v\notin X$}
\State{Add $e$ to $T$}
\State{Add $v$ to $X$}
\EndWhile
\end{algorithmic}
\end{algorithm}
We will prove its correctness in two steps. First, we verify that it does compute a spanning tree $T^*$. Then we prove that $T^*$ is an MST. 
\begin{lemma}\textbf{(Empty Cut Lemma)}\label{emptycutlemma}
A graph is not connect if and only if $\exists$ cut $(A,B)$ with no crossing edges.
\end{lemma}
\begin{proof}
$(\Leftarrow)$The proof is trivial. Just take vertex $u\in A$ and $v\in B$. There cannot exist any edges between $u,v$, thus the graph is not connected.

$(\Rightarrow)$Suppose there exists no edge between $u,v$. Take $A=\{$All vertices reachable from $u\}$, i.e. the connected component of $u$, $B=\{$All other vertices$\}$, i.e. other connected components. Then there exists no crossing edges of the cut $(A,B)$.
\end{proof}
\begin{lemma}\label{doublecrossinglemma}
\textbf{(Double Crossing Lemma)}
Suppose the cycle $C\subseteq E$ has an edge crossing the cut $(A,B)$, then there must exist some other edge $e\in C$ that crosses the same cut.
\end{lemma}
\begin{corollary}
\textbf{(Lonely Cut Corollary)}\label{lonelycutcorollary}
If $e$ is the only edge crossing a cut $(A,B)$, then it is not contained in any cycle.
\end{corollary}
With the lemmas and the corollaries above, we can prove that Prim's algorithm outputs a spanning tree.
\begin{proof}
It can be proved by induction that Prim's algorithm maintains the invariant that $T$ spans $X$. The proof of connectivity is trivial. No cycle can be created in $T$ because each time an edge $e$ is added into $T$, it becomes the only crossing edge of the cut $(X,\{v\})$ of $T$, and therefore cannot be contained in a cycle according to Corollary \ref{lonelycutcorollary}. 

The algorithm cannot get stuck when $X\neq V$, because otherwise the cut $(X,V-X)$ must be empty, and according to Lemma \ref{emptycutlemma}, the graph would be disconnected. 

As a conclusion, Prim's algorithm is guaranteed to output a spanning tree of the original graph.
\end{proof}
The second part of the proof is based on the cut property.
\begin{theorem}
\textbf{(Cut Property)}
Consider an edge $e$ of graph $G$. If $\exists$ cut $(A,B)$ such that $e$ is the cheapest crossing edge of the cut, then $e$ belongs to the\footnote{We use ``the'' rather than ``a'' because the MST is unique if edge costs are distinct.} MST of $G$.
\end{theorem}
\begin{proof}
The cut proof can be proved by exchange argument.

Suppose there is an edge $e$ that is the cheapest crossing edge of a cut $(A,B)$, yet $e$ is not in the MST $T^*$. As shown in Figure \ref{proofcutproperty}, in which all blue edges form the minimum spanning tree $T^*$, and the minimum crossing edge $e$ of $(A,B)$ is not contained in $T^*$.
\begin{figure}[ht]
\centering
\begin{tikzpicture}
\tikzstyle{nodestyle} = [circle, draw=blue, fill=blue!20!]
\tikzstyle{usualedge} = [blue, very thick]
\tikzstyle{emphedge} = [red, very thick]
\tikzstyle{label} = [midway, above]
\node (A) at (-2,0.5) {A};
\node (B) at (2,0.5) {B};
\node[nodestyle](1) at (-2,0){1};
\node[nodestyle](2) at (-2,-1){2};
\node[nodestyle](3) at (-2,-2){3};
\node[nodestyle](4) at (2,0){4};
\node[nodestyle](5) at (2,-1){5};
\node[nodestyle](6) at (2,-2){6};
\draw[usualedge] (1) -- (2);
\draw[usualedge] (2) -- (3);
\draw[usualedge] (1) -- (4) node[label] {f};
\draw[emphedge] (2) -- (5) node[label] {e};
\draw[usualedge] (3) -- (6) node[label] {e'};
\draw[usualedge] (5) -- (6);
\draw (2) ellipse (1cm and 2cm);
\draw (5) ellipse (1cm and 2cm);
\end{tikzpicture}
\caption{Proof of cut property}\label{proofcutproperty}
\end{figure}

We cannot exchange $e$ with a random crossing edge of the cut $(A,B)$. In this example, if we exchange $e$ with $f$, we no longer have a spanning tree. Rather, if $e$ is exchanged with $e'$, we obtain a spanning tree with smaller cost than $T^*$. Our task is to prove that such an edge $e'$ always exists. 

Since $T^*$ is a spanning tree, $T^*\cup\{e\}$ must contains a cycle that includes $e$. According to Lemma \ref{doublecrossinglemma}, there must exist another edge $e'$ that crosses the cut $(A,B)$. According to the assumption, $e'$ must be more expensive than $e$. By substituting $e'$ with $e$ in $T^*$, we obtain a spanning tree $(T^*-\{e'\})\cup\{e\}$ with smaller cost than $T^*$, which contradicts with our assumption that $T^*$ is the MST.
\end{proof}

According to the cut property, each edge selected in Prim's algorithm is guaranteed to be part of the MST. Since we obtain a spanning tree in the end, it must be the MST. 
\ifx\PREAMBLE\undefined
\end{document}
\fi